// @ts-nocheck
// 前言：
// js存在垃圾回收机制：回收不再被引用的变量，闭包中内层函数连接了外层函数的作用域，因此存在引用，不会被销毁回收
// 一般情况下，在函数(作用域)中创建的变量会随着函数执行结束被回收
// 而当形成闭包，外层函数的变量保留

function outer() { // 外层函数
  let count = 0;
  function inner(){ // 内层函数连接外层函数作用域，因此可以访问到count
    count++;
    console.log(count);
  }
  return inner;
}

// 闭包可以将外层变量绑定到内层函数上，从而可以在任何地方运行内层函数并访问外层作用域的变量
let fn = outer(); // 调用 outer 返回函数 inner 并赋值给fn
fn() // 调用 fn
fn() // 第二次调用已经实现的闭包环境，会保留原来的变量和其值

fn = null; // 清理引用，允许垃圾回收机制回收闭包

// 注意：每次调用outer创建新的闭包环境，每个环境独立，因此不会保留原来的变量和其值
outer()()
outer()()